class Solution(object):
    def coinChange(self, coins, amount):
        """
        :type coins: List[int]
        :type amount: int
        :rtype: int
        """

        '''
        OPT = [float('inf')] * (amount + 1)
        OPT[0] = 0  # base case: 0 amount needs 0 coins
        
        for i in range(1, amount + 1):
            for coin in coins:
                if i >= coin:
                    OPT[i] = min(OPT[i], OPT[i - coin] + 1)
        
        # If OPT[amount] is still infinity, it's impossible to make that amount
        return OPT[amount] if OPT[amount] != float('inf') else -1
        '''

 
        OPT = [float('inf')] * (amount + 1)
        OPT[0] = 0
        parent = [-1] * (amount + 1)  # track which coin was used
        
        for i in range(1, amount + 1):
            for coin in coins:
                if i >= coin and OPT[i - coin] + 1 < OPT[i]:
                    OPT[i] = OPT[i - coin] + 1
                    parent[i] = coin  # remember which coin we used
        
        if OPT[amount] == float('inf'):
            return -1
        else:
            return OPT[amount]
        
        '''
        # Reconstruct the coins used
        result = []
        j = amount
        while j > 0:
            coin_used = parent[j]
            result.append(coin_used)
            j = j - coin_used
        
        return OPT[amount]
        '''
